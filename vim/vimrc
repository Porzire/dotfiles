" Author: Jie Mei
" Since:  2016.05.08

" System judgement values.
let s:is_win = has("win16") || has("win32") || has("win64") || has("win95") ? 1 : 0
let s:is_mac = has("mac") ? 1 : 0

""""""""""""""""""""""""""""""""""" General """"""""""""""""""""""""""""""""""""

" Add dropbox RTP
if s:is_win
  set runtimepath+=A:\Dropbox\vim\runtimepath
  set runtimepath+=A:\Dropbox\vim\runtimepath\bundle\Vundle.vim
else
  set runtimepath+=$HOME/Dropbox/vim/runtimepath
  set runtimepath+=$HOME/Dropbox/vim/runtimepath/bundle/Vundle.vim
endif

set nocompatible  " Set Vim not VI-compatible.
filetype off      " required

set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'VundleVim/Vundle.vim'       " Vimscript package manager.
Plugin 'Porzire/freya'              " Colour scheme.
Plugin 'vimcdoc'                    " Vim online documentation Chinese version.
Plugin 'scrooloose/nerdtree'        " A tree explorer for navigating the system.
Plugin 'taglist.vim'                " Source code browser.
Plugin 'auctex.vim'                 " Macros for latex.
Plugin 'surround.vim'               " Edit parentheses with ease.
Plugin 'Markdown'                   " Syntax highlight for Markdown text files.
Plugin 'editorconfig/editorconfig-vim' " Support editor config.
Plugin 'netrw.vim'                  " Remote tree explorer.
Bundle 'Lokaltog/powerline', {'rtp': 'powerline/bindings/vim/'}
Plugin 'Yggdroot/indentLine'        " Display indentation.
Plugin 'jiangmiao/auto-pairs'
Plugin 'autowitch/hive.vim'         " Hive syntax
Plugin 'tmhedberg/SimpylFold'
Plugin 'neilagabriel/vim-geeknote'

call vundle#end() 

" Behavior support.
behave mswin                     " Set mouse behave to be Ms-Windows.
if s:is_mac && has('gui_running')
	source $VIMRUNTIME/macmap.vim  " Allow mappping with command-key.
elseif s:is_win
  source $VIMRUNTIME/mswin.vim   " Allow using CTRL-X, CTRL-C and CTRL-V.
  if has('mouse')
    set mouse=a                  " Allow using mouse in all modes.
  endif
  au GUIEnter * simalt ~x
endif

" Language setings.
if has("multi_lang")
  set helplang=cn,en  " Use Chinese help document (require download).
  if has("menu")
    set langmenu=en   " Use Chinese menu.
  endif
endif

colorscheme freya

set history=1000  " The number of history is remembered.

if has("wildmenu")
  set wildmenu  " Command-line completion operates in an enhanced mode.
endif

set backspace=indent,eol,start whichwrap+=<,>,[,]

" Disable auto backup.
set nobackup
set nowritebackup

" Automatic read the latest modification into buffer.
if exists("&autoread")
	set autoread
endif

"set fileformat=unix,mac,dos  " 设置换行符(<EOF>)格式的优先级

xnoremap p pgvy  " Aviod resetting clipboard.


""""""""""""""""""""""""""""""""""" Encoding """""""""""""""""""""""""""""""""""

" Set file encoding.
if has('multi_byte')
  set encoding=utf-8
  set fileencoding=utf-8
  set fileencodings=ucs-bom,utf-8,chinese,cp936,gbk,big5,latin-1
  if v:lang =~? '^\(zh\)\|\(ja\)\|\(ko\)'
    set ambiwidth=double  " Double width the Unicode characters.
  endif
  set nobomb
endif

" Set fonts.
if has('gui_running')
  if s:is_mac
    set guifont=Inconsolata\ for\ Powerline:h14
  elseif
    set guifont=Inconsolata:h12,Menlo:h12
    set gfw=SimHei:h11:cGB2312
  endif
endif


"""""""""""""""""""""""""""""""""" Interface """""""""""""""""""""""""""""""""""


set shortmess=atI  " Aviod hit-enter prompts caused by file message.

set laststatus=2  " Always has a status line.

" Disable syntax menus.
let did_install_syntax_menu=1

if has("gui_running")
	set guioptions-=m                " Menu bar             is NOT present.
	set guioptions-=T                " Toolbar              is NOT presnet.
	set guioptions-=l guioptions-=L  " Left-hand scrollbar  is NOT present.
	set guioptions-=r guioptions-=R  " Right-hand scrollbar is NOT present.
	set guioptions-=b                " Bottom scrollbar     is NOT present.
endif

set scrolloff=3  " Minimal number of lines to keep above and below the cursor.

if has('cmdline_info')
	set showcmd  " Show command in the last line fo the screen.
	set ruler    " Show the line and column number of the cursor position.
endif

if has('statusline')
	set rulerformat=%17(:b%n\ \ %l,%c%V\ %=%P%)  " ruler string.
endif


"""""""""""""""""""""""""""""""""""" Search """"""""""""""""""""""""""""""""""""


if has("extra_search")
  set incsearch  " Show first matching when insert searching.
  set hlsearch   " Highlight matchings.
endif

set magic  " Changes the special characters that can be used in search patterns.

set ignorecase smartcase  " Ignore case if search with all lowercase characters.


""""""""""""""""""""""""""""""""""""" Edit """""""""""""""""""""""""""""""""""""


set lazyredraw  " The screen will not be redrawn while executing macros.

set report=0  " Always report the number of lines changed.

if has("gui_running")
  set linespace=0  " TWO pixel lines inserted between characters.
endif

" Always use space.
set tabstop=2      " TWO spaces that a <Tab> in the file counts for.
set shiftwidth=2   " TWO spaces to use for each step of (auto)indent.
set softtabstop=2  " TWO spaces that a <Tab> counts for when editing.
set expandtab      " TWO spaces that used used to insert a tab.

" Jump to the matching one for 0.1 second when a bracket is inserted.
set showmatch matchtime=1

if has("linebreak")
  " Wrap long lines with indentation for buffer display.
  set linebreak  " NOTE: breakindent is not supported in some system.
endif

filetype on
filetype plugin on  " (required by Latex-Suite)
filetype indent on
filetype plugin indent on

se number nowrap

if has("autocmd")
  augroup vimrcEx
    autocmd!

    autocmd! BufEnter * lcd %:p:h

    " autocmd! BufRead,BufNewFile  setfiletype text

    autocmd FileType matlab setlocal textwidth=75
    autocmd FileType text,mkd setlocal textwidth=0 nonumber wrap
  augroup end
endif

if has("cindent")
  set cindent
else
  set autoindent
  if has("cindent")
    set smartindent
  endif
endif


"""""""""""""""""""""""""""""""""""" Syntax """"""""""""""""""""""""""""""""""""


set textwidth=80    " Maximum width of text that is being inserted.

if has("syntax")
  syntax enable        " Enable syntax highlighting.
  set synmaxcol=10000  " Maximum column in which to search for syntax items.

  set colorcolumn=+1   " The screen column that is being highlighted.
  " if has("autocmd")
  "   " Automatic color the overflowed columns.
  "   augroup autoColorColumn
  "     autocmd!
  "     autocmd BufEnter,VimResized * let &cc=GetColorColumn()
  "     function! GetColorColumn()
  "       """ Get a list string of overflowed columns, separated by comma.
  "       """
  "       let l:columns = winwidth(0) - &tw - &fdc
  "       let l:cc = "+1"
  "       if l:columns > 1
  "         for l:val in range(2, l:columns)
  "           let l:cc = l:cc . ",+" . l:val
  "         endfor
  "       endif
  "       return l:cc
  "     endfunc
  "   augroup end
  " endif

  set cursorline       " Highlight the screen line of the cursor.
  set nocursorcolumn   " Not highlight the screen column of the cursor.

  if has("autocmd")
    " Check spell for text file.
    augroup textSpellCheck
      autocmd!
      autocmd FileType txt setlocal spell
    augroup end
  endif
endif

" Language specific syntax.
" Apache
let apache_version = "2.0"      " Highlight accoding to Apache 2.0.
" C
let c_comment_strings = 1       " Highlight strings and numbers in the comment.
let c_space_errors    = 1       " Highlight space errors.
let c_curly_error     = 1       " Highlight missing curly bracket.
" Java
let java_highlight_debug = 1    " Highlight debuging statements.
" MySQL
let msql_sql_query = 1          " Highlight SQL.
" Pascal
let pascal_symbol_operator = 1  " Highlight operators.
" PHP
let g:php_sql_query     = 1     " Highlight SQL.
let g:php_htmlInStrings = 1     " Highlight HTML.
let g:php_asp_tags      = 1     " Highlight ASP tags.
" Python
let g:python_highlight_all = 1  " Highlight all possible syntax.
" Ruby
let g:ruby_operators    = 1     " Highlight operators.
let g:ruby_space_errors = 1     " Highlight space errors.
" Vimscript
let g:vimsyn_embed   = "mpPrt"  " Allow all scripts embeded.
let g:vimsyn_noerror = 1        " Disable error hightlight.

" Increase sync lines to aviod highting problems.
let g:c_minlines      = 200
let g:msql_minlines   = 200
let g:perl_sync_dist  = 200
let g:ruby_minlines   = 200
let g:sh_minlines     = 200
let g:vimsyn_minlines = 200
let g:java_minlines   = 200


""""""""""""""""""""""""""""""""""" Folding """"""""""""""""""""""""""""""""""""

if has("folding")
  set foldenable                  " Enable folds.
  set foldminlines=0              " Able to close fold of any number of lines.

  if has("windows")
    set fillchars=fold:\	        " Use space to fill the folding line.
  endif

  set foldtext=FoldText()
  function! FoldText()
    """ Return folding information, which is defined as the concatenation of
    """ three components: content short cut, padding, and folded line count.
    """
    " Compute folded line count (ft_lc)
    let l:lines = v:foldend - v:foldstart
    if l:lines > 1
      let l:ft_lc = l:lines . ' lines'
    else
      let l:ft_lc = '1 line'
    endif
    " Compute content shortcut (ft_sc)
    let l:start = getline(v:foldstart)
    let l:end = getline(v:foldend)
    if match(l:end, 'end') >= 0 || &filetype == 'python'
      let l:ft_sc = l:start
    else
      let l:ft_sc = l:start . ' ... ' . strpart(l:end, match(l:end, '\S'))
    endif
    " Compute padding (ft_pad)
    let l:psize = &tw - len(l:ft_sc) - len(l:ft_lc) - 3
    let l:ft_pad = ' ' . repeat('-', l:psize) . '+ '
    "
    return l:ft_sc . l:ft_pad . l:ft_lc
  endfunc

  if has("autocmd")
    " Automatic update fold column according to the maximun folding levels.
    augroup autoFoldColumn
      autocmd!
      autocmd BufWinEnter,BufWritePost * let &fdc=GetFoldColumn()
      function! GetFoldColumn()
        """ Get the minimum number of fold column required for display.
        """
        let l:maxfoldlvl = 0
        for l:idx in range(1, line("$"))
          let l:lvl = foldlevel(l:idx)
          if l:lvl > l:maxfoldlvl
            let l:maxfoldlvl = l:lvl
          endif
        endfor
        return l:maxfoldlvl < 12 ? l:maxfoldlvl + 1 : 12
      endfunc
    augroup end
  endif
endif

" Language specific foldings.
let g:c_no_comment_fold  = 1          " Comments not fold. 
let g:vimsyn_folding     = "afmpPrt"  " Fold autogroups, functions and scripts.
let g:sh_fold_enabled    = 1          " Fold functions.
let g:php_folding        = 1
let g:ruby_fold          = 1
let g:perl_fold          = 1

if has("autocmd")
  " Automatic close all folds when openning a new buffer.
  augroup autoFold
    autocmd!
    autocmd BufCreate *.{vim,js,pl,php,r,ruby,sh,xml,java},vimrc exec "norm! zm"
  augroup end
endif

"""""""""""""""""""""""""""""""""""" Others """"""""""""""""""""""""""""""""""""

if has('autocmd')
  " Automatic update last modification time.
  augroup autoTimeUpdate
    autocmd!

    " Automatic update @since to the current date for Java source code.
    autocmd BufWritePre,FileWritePre *.java
          \ ks|call AutoTimeUpdate("^[ *\t]*@since", "@since")|'s

    " Automatic update last modification date for HTML source code.
    autocmd BufWritePre,FileWritePre *.html
          \ ks|call AutoTimeUpdate("Last modified:")|'s

    " Automatic update last modification date for vimrc.
    autocmd BufWritePre,FileWritePre vimrc
          \ ks|call AutoTimeUpdate("Since:", "Since: ")|'s

    function! AutoTimeUpdate(pattern, ...)
      """ Automatic update date information for the current buffer.
      """ Args:
      """   pattern: the pattern used to identify the updating line.
      """   prefix:  the previous word of the date information, optional. If
      """            this parameter is not given, the date information will be
      """            placed after the line pattern.
      """ 
      if line("$") > 20
        let l:l = 20
      else
        let l:l = line("$")
      endif
      if exists("*strftime")
        if a:0 >= 1
          exe "silent 1," . l:l . "g/" . a:pattern . "/s/" . a:1 . ".*$/" . a:1 .
              \ " " . strftime("%Y.%m.%d")
        else
          exe "silent 1," . l:l . "g/" . a:pattern . "/s/" . a:pattern . ".*$/" .
              \  a:pattern . " " . strftime("%Y.%m.%d")
        endif
      endif
    endfunc
  augroup end

  " Backup the last reading position when openning a file.
  augroup autoBackupPos
    autocmd!
    autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif
  augroup end

  " Automatic read view file when openning a file.
  augroup autoLoadView
    autocmd!
    autocmd BufWinEnter ?* silent loadview
  augroup end
endif

vnoremap // y/<C-R>"<CR>

" Switch folding status with space.
nnoremap <space> @=((foldclosed(line('.')) < 0) ? 'zc':'zo')<CR>

"  Rearrange format when inserting linebreak in an empty curly brace.
"inoremap <CR> <ESC>:call CheckCurlyBrace()<CR>a<CR>
"function! CheckCurlyBrace()
"  let l:line = getline(".")
"  let l:prev_char = l:line[col(".") - 1]
"  let l:next_char = l:line[col(".")]
"  if ('{' == l:prev_char && '}' == l:next_char)
"    execute "norm! a\<CR>"
"  execute "norm! k$"
"  end
"endfunc

" Auto-complete brackets.
inoremap ( ()<LEFT>
inoremap [ []<LEFT>
inoremap { {}<LEFT>
" inoremap " ""<LEFT>
" inoremap ' ''<LEFT>

" Aviod inserting the duplicate second half bracket.
inoremap ) <ESC>:call RemoveNextDuplicate(')')<CR>a
inoremap ] <ESC>:call RemoveNextDuplicate(']')<CR>a
inoremap } <ESC>:call RemoveNextDuplicate('}')<CR>a
function! RemoveNextDuplicate(char)
  let l:line = getline(".")
  let l:next_char = l:line[col(".")]
  if a:char == l:next_char
    execute "normal! l"
  else
    execute "normal! a" . a:char . ""
  end
endfunc

" Switch between tab pages.
nmap gT <ESC>:tabp<CR>
nmap gt <ESC>:tabn<CR>

" line up/down-ward linewise.
map <d-j> 5j
map <c-j> 5j
map <d-k> 5k
map <c-k> 5k

" Run program.
if s:is_mac
	map <d-0> :call RunProgram()<CR>
else
	map <c-F10> :call RunProgram()<CR>
endif
function! RunProgram()
  if &filetype == 'c'
    if s:is_win
      exec "! %<.exe"
    else
      exec "! ./%<"
    endif
  elseif &filetype == 'cpp'
    exec "! ./%<"
  elseif &filetype == 'java'
    exec "!java %<"
  elseif &filetype == 'sh'
    exec "! ./%"
	elseif &filetype == 'html'
    exec "!open %"
	elseif &filetype == 'xhtml'
    exec "!open %"
	elseif &filetype == 'r'
    exec "!Rscript %"
	elseif &filetype == 'python'
    if s:is_win
      exec "!B:\\Python27\\python.exe %"
    else
      exec "!python %"
    endif
	elseif &filetype == 'perl'
    exec "!perl %"
	elseif &filetype == 'tex'
    if s:is_win
      call Tex_ViewLaTeX()
    elseif s:is_mac
      exec "!open %<\.pdf"
    else
      exec "!okular %<\.pdf"
    endif
	elseif &filetype == ('mmd' || 'mkd' || 'markdown')
    if s:is_win
      exec "!chrome \"%\""
    else
      exec "!open -a 'Marked\ 2.app' %:p"
      " Open with Chrome in mac.
      " exec "!open -a \"/Applications/Google\ Chrome.app\" \"%\""
    endif
  endif
endfunction


if s:is_mac
	map <d-9> :call RunCompiler()<CR>
else
	map <c-F9> :call RunCompiler()<CR>
endif
function! RunCompiler()
  exec "w"
  if     &filetype == 'c'
    exec "!gcc -Wall -g -o %< %"
  elseif &filetype == 'cpp'
    exec "!g++ -o %< %"
  elseif &filetype == 'java'
    exec "!javac -g %" 
  elseif &filetype == 'mmd'
    exec "!multimarkdown \"%\" >  \"%<\.markdown\"" 
  elseif &filetype == 'tex'
    if s:is_win
      call Tex_RunLaTeX()
    else
      exec "!pdflatex -interaction=nonstopmode %"
    endif
  endif
endfunc


function! DoPrettyXML()
  " save the filetype so we can restore it later
  let l:origft = &ft
  set ft=
  " delete the xml header if it exists. This will permit us to surround the
  " document with fake tags without creating invalid xml.
  1s/<?xml .*?>//e
  " insert fake tags around the entire document.  This will permit us to
  " pretty-format excerpts of XML that may contain multiple top-level elements.
  0put ='<PrettyXML>'
  $put ='</PrettyXML>'
  silent %!xmllint --format -
  " xmllint will insert an <?xml?> header. it's easy enough to delete if you
  " don't want it.  delete the fake tags
  2d
  $d
  " restore the 'normal' indentation, which is one extra level too deep due to
  " the extra tags we wrapped around the document.
  silent %<
  " back to home
  1
  " restore the filetype
  exe "set ft=" . l:origft
endfunction
command! PrettyXML call DoPrettyXML()


""""""""""""""""""""""""""""""""""" Plguins """"""""""""""""""""""""""""""""""""

"execute pathogen#infect() 

" NERD tree
map <c-o> :NERDTreeToggle<CR>
imap <c-o> <ESC>:NERDTreeToggle<CR>
let NERDTreeIgnore=['\.pyc']
" let g:NERDTreeWinSize = 37
let g:NERDTreeForceMac = 1
" Close Vim if NERDTree is the last buffer.
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType")
  \&& b:NERDTreeType == "primary") | q | endif

" Taglist
map <c-p> :TlistToggle<CR>
imap <c-p> <ESC>:TlistToggle<CR>
" Installing path.
if s:is_win
    let Tlist_Ctags_Cmd = 'A:/Dropbox/vim/runtimepath/bundle/ctags'
elseif s:is_mac
    let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'
else
    let Tlist_Ctags_Cmd = '/usr/bin/ctags'
endif
let Tlist_Show_One_File = 1     " Only show tags of the focused window.
let Tlist_Exit_OnlyWindow = 1   " If taglist is the last window，exit Vim.
let Tlist_Use_Right_Window = 1  " Show taglist window on right.
let Tlist_WinWidth = 31

" indentLine
let g:indentLine_char = '┆'
let g:indentLine_color_gui = '#928374'

" vim-markdown
autocmd BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}  set filetype=mkd
let g:vim_markdown_folding_disabled=1  " Disable folding.
let g:vim_markdown_initial_foldlevel=1  " Set the initial fold level.
    " This option defaults to 0 (i.e. all folds are closed) and is ignored if
    " folding is disabled.

" netrw
" behave like NERDTree.
let g:netrw_winsize = -28     " Absolute width of netrw window.
let g:netrw_banner = 0        " Do not display info on the top of window.
let g:netrw_liststyle = 3     " Apply tree-view.
let g:netrw_browse_split = 4  " Use the previous window to open file.
let g:netrw_sort_sequence = '[\/]$,*'
                " Sort is affecting only: directories on the top, files below.
" :Lexplore opens it on left side, :Lexplore! on the right
com! -nargs=* -bar -bang -complete=dir Lexplore 
      \ call netrw#Lexplore(<q-args>, <bang>0)
fun! Lexplore(dir, right)
  if exists("t:netrw_lexbufnr")
  " close down netrw explorer window
  let lexwinnr = bufwinnr(t:netrw_lexbufnr)
  if lexwinnr != -1
    let curwin = winnr()
    exe lexwinnr."wincmd w"
    close
    exe curwin."wincmd w"
  endif
  unlet t:netrw_lexbufnr

  else
    " open netrw explorer window in the dir of current file
    " (even on remote files)
    let path = substitute(exists("b:netrw_curdir")? b:netrw_curdir : expand("%:p"), '^\(.*[/\\]\)[^/\\]*$','\1','e')
    exe (a:right? "botright" : "topleft")." vertical ".((g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize) . " new"
    if a:dir != ""
      exe "Explore ".a:dir
    else
      exe "Explore ".path
    endif
    setlocal winfixwidth
    let t:netrw_lexbufnr = bufnr("%")
  endif
endfun

" Hive syntax
au BufNewFile,BufRead *.hql set filetype=hive expandtab
au BufNewFile,BufRead *.q set filetype=hive expandtab

" SimpylFold
let g:SimpylFold_docstring_preview = 0
let g:SimpylFold_fold_docstring = 0
let g:SimpylFold_fold_import = 0

"""""""""" LaTex-Suit """""""""
" 
" " REQUIRED: This makes vim invoke Latex-Suite when you open a tex file.
" " filetype plugin on
" 
" " IMPORTANT: win32 users will need to have 'shellslash' set so that latex
" " can be called correctly.
" set shellslash
" 
" " IMPORTANT: grep will sometimes skip displaying the file name if you search in a singe file.
" " This will confuse Latex-Suite. Set your grep program to always generate a file-name.
" set grepprg=grep\ -nH\ $*
" 
" " OPTIONAL: This enables automatic indentation as you type.
" " filetype indent on
" 
" " OPTIONAL: Starting with Vim 7, the filetype of empty .tex files defaults to 'plaintex' instead of 'tex', which results in vim-latex not being loaded.
" " The following changes the default filetype back to 'tex':
" let g:tex_flavor='latex'
" 
" " TIP: if you write your \label's as \label{fig:something}, then if you
" " type in \ref{fig: and press <C-n> you will automatically cycle through
" " all the figure labels. Very useful!
" set iskeyword+=:
" 
" if s:is_mac
"     let g:Tex_defaultTargetFormat='pdf'
" else
"     let g:Tex_defaultTargetFormat='dvi'
" endif

"""""""""" Geeknote """""""""

let g:GeeknoteFormat="markdown"
